#!/usr/bin/env python3
"""
å®Œæ•´çš„å®¢æœç³»ç»ŸAPIæœåŠ¡
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional
import uvicorn
import os

# å¯¼å…¥æˆ‘ä»¬ä¹‹å‰åˆ›å»ºçš„æ¨¡å—
from .document_processor import DocumentProcessor
from .vector_search import VectorSearch

# åˆ›å»ºFastAPIåº”ç”¨
app = FastAPI(
# é…ç½®é™æ€æ–‡ä»¶å’Œç½‘é¡µ
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse

# æ·»åŠ é™æ€æ–‡ä»¶æœåŠ¡ï¼ˆå¦‚æœéœ€è¦çš„è¯ï¼‰
# app.mount("/static", StaticFiles(directory="static"), name="static")
    title="æ™ºèƒ½å®¢æœç³»ç»Ÿ",
    description="åŸºäºRAGæ¶æ„çš„æ™ºèƒ½å®¢æœé—®ç­”ç³»ç»Ÿ",
    version="1.0.0"
)

# å…¨å±€å˜é‡å­˜å‚¨æˆ‘ä»¬çš„ç³»ç»Ÿç»„ä»¶
search_system = None
processor = None

class QuestionRequest(BaseModel):
    """é—®ç­”è¯·æ±‚æ•°æ®ç»“æ„"""
    question: str
    top_k: Optional[int] = 3

class AnswerResponse(BaseModel):
    """é—®ç­”å“åº”æ•°æ®ç»“æ„"""
    question: str
    answer: str
    relevant_documents: List[str]
    success: bool

@app.on_event("startup")
async def startup_event():
    """æœåŠ¡å¯åŠ¨æ—¶åˆå§‹åŒ–ç³»ç»Ÿ"""
    global search_system, processor
    
    print("ğŸš€ æ­£åœ¨å¯åŠ¨æ™ºèƒ½å®¢æœç³»ç»Ÿ...")
    
    try:
        # 1. åˆå§‹åŒ–æ–‡æ¡£å¤„ç†å™¨
        processor = DocumentProcessor()
        
        # 2. åŠ è½½æ–‡æ¡£
        documents = processor.load_documents("data/return_policy.txt")
        
        # 3. åˆå§‹åŒ–å‘é‡æœç´¢ç³»ç»Ÿ
        search_system = VectorSearch()
        
        # 4. å°†æ–‡æ¡£æ·»åŠ åˆ°å‘é‡æ•°æ®åº“
        search_system.add_documents(documents)
        
        print("âœ… æ™ºèƒ½å®¢æœç³»ç»Ÿå¯åŠ¨å®Œæˆï¼")
        
    except Exception as e:
        print(f"âŒ ç³»ç»Ÿå¯åŠ¨å¤±è´¥: {e}")
        raise

@app.get("/")
async def root():
    """æ ¹è·¯å¾„ï¼Œæä¾›åŸºç¡€ä¿¡æ¯"""
    return {
        "message": "æ¬¢è¿ä½¿ç”¨æ™ºèƒ½å®¢æœç³»ç»Ÿï¼",
        "version": "1.0.0",
        "endpoints": {
            "health": "/health",
            "ask": "/ask (POST)",
            "docs": "/docs"
        }
    }

@app.get("/health")
async def health_check():
    """å¥åº·æ£€æŸ¥ç«¯ç‚¹"""
    return {
        "status": "healthy",
        "service": "smart-customer-service",
        "components": {
            "vector_database": "ready",
            "embedding_model": "ready"
        }
    }

@app.post("/ask", response_model=AnswerResponse)

@app.get("/", response_class=HTMLResponse)
async def chat_interface():
    """æä¾›èŠå¤©ç•Œé¢"""
    try:
        with open("templates/chat.html", "r", encoding="utf-8") as f:
            html_content = f.read()
        return HTMLResponse(content=html_content)
    except FileNotFoundError:
        return HTMLResponse(content="<h1>èŠå¤©ç•Œé¢æ–‡ä»¶æœªæ‰¾åˆ°</h1><p>è¯·ç¡®ä¿ templates/chat.html å­˜åœ¨</p>", status_code=404)

@app.get("/chat", response_class=HTMLResponse)
async def chat_page():
    """èŠå¤©é¡µé¢ï¼ˆé‡å®šå‘åˆ°é¦–é¡µï¼‰"""
    return RedirectResponse(url="/")
async def ask_question(request: QuestionRequest):
    """
    æ™ºèƒ½é—®ç­”æ¥å£
    """
    try:
        print(f"ğŸ“¨ æ”¶åˆ°é—®é¢˜: {request.question}")
        
        # 1. ä½¿ç”¨å‘é‡æœç´¢æ‰¾åˆ°ç›¸å…³æ–‡æ¡£
        relevant_docs = search_system.search(request.question, request.top_k)
        
        # 2. åŸºäºç›¸å…³æ–‡æ¡£ç”Ÿæˆå›ç­”
        if relevant_docs:
            # è¿™é‡Œæˆ‘ä»¬å…ˆåšä¸€ä¸ªç®€å•çš„å›ç­”ç”Ÿæˆ
            # åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œè¿™é‡Œä¼šè°ƒç”¨å¤§è¯­è¨€æ¨¡å‹ï¼ˆå¦‚DeepSeekï¼‰
            answer = generate_simple_answer(request.question, relevant_docs)
            success = True
        else:
            answer = "æŠ±æ­‰ï¼Œæˆ‘æ²¡æœ‰æ‰¾åˆ°ç›¸å…³çš„æ”¿ç­–ä¿¡æ¯ã€‚è¯·å°è¯•æ¢ä¸€ç§æ–¹å¼æé—®ï¼Œæˆ–è”ç³»äººå·¥å®¢æœã€‚"
            success = False
        
        return AnswerResponse(
            question=request.question,
            answer=answer,
            relevant_documents=relevant_docs,
            success=success
        )
        
    except Exception as e:
        print(f"âŒ å¤„ç†é—®é¢˜æ—¶å‡ºé”™: {e}")
        raise HTTPException(status_code=500, detail=f"å¤„ç†é—®é¢˜æ—¶å‡ºé”™: {str(e)}")

def generate_simple_answer(question: str, relevant_docs: List[str]) -> str:
    """
    ç®€å•çš„å›ç­”ç”Ÿæˆå‡½æ•°
    åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œè¿™é‡Œä¼šè°ƒç”¨å¤§è¯­è¨€æ¨¡å‹
    """
    # å°†ç›¸å…³æ–‡æ¡£æ‹¼æ¥èµ·æ¥
    context = "\n".join([f"- {doc}" for doc in relevant_docs])
    
    # åŸºäºé—®é¢˜å’Œä¸Šä¸‹æ–‡ç”Ÿæˆç®€å•å›ç­”
    answer = f"æ ¹æ®æˆ‘ä»¬çš„æ”¿ç­–ä¿¡æ¯ï¼š\n{context}\n\nå¦‚æœæ‚¨éœ€è¦æ›´è¯¦ç»†çš„å¸®åŠ©ï¼Œè¯·è”ç³»å®¢æœã€‚"
    
    return answer

def run_service():
    """å¯åŠ¨WebæœåŠ¡"""
    print("ğŸŒ å¯åŠ¨WebæœåŠ¡...")
    print("ğŸ“ æœåŠ¡åœ°å€: http://localhost:8000")
    print("ğŸ“š APIæ–‡æ¡£: http://localhost:8000/docs")
    print("â¹ï¸  æŒ‰ Ctrl+C åœæ­¢æœåŠ¡")
    print("-" * 50)
    
    uvicorn.run(app, host="0.0.0.0", port=8000)

if __name__ == "__main__":
    run_service()
