"""
æ™ºèƒ½å®¢æœAPIæœåŠ¡ - å¸¦ç½‘é¡µç•Œé¢ç‰ˆæœ¬
"""
import os
import sys
from pathlib import Path

# ç¦ç”¨ChromaDBé¥æµ‹ï¼ˆå‡å°‘æ—¥å¿—å™ªéŸ³ï¼‰
os.environ['ANONYMIZED_TELEMETRY'] = 'False'

from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse, RedirectResponse
from pydantic import BaseModel
from typing import List, Optional
import uvicorn
import logging
from datetime import datetime

# å¯¼å…¥æœ¬åœ°æ¨¡å—
from .document_processor import DocumentProcessor
from .vector_search import VectorSearch

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="æ™ºèƒ½å®¢æœé—®ç­”ç³»ç»Ÿ",
    description="åŸºäºAIçš„æ™ºèƒ½å®¢æœç³»ç»Ÿï¼Œæä¾›Webç•Œé¢å’ŒAPI",
    version="2.0.0"
)

# è¯·æ±‚/å“åº”æ¨¡å‹
class QuestionRequest(BaseModel):
    question: str
    user_id: Optional[str] = "anonymous"
    conversation_id: Optional[str] = None

class QuestionResponse(BaseModel):
    status: str
    answer: str
    confidence: Optional[float] = None
    sources: Optional[List] = None
    timestamp: str

# å…¨å±€å˜é‡
vector_search = None
processor = None

@app.on_event("startup")
async def startup_event():
    """å¯åŠ¨äº‹ä»¶ï¼šåˆå§‹åŒ–ç³»ç»Ÿ"""
    global vector_search, processor
    
    try:
        logger.info("ğŸš€ æ­£åœ¨å¯åŠ¨æ™ºèƒ½å®¢æœç³»ç»Ÿ...")
        
        # åˆå§‹åŒ–æ–‡æ¡£å¤„ç†å™¨
        processor = DocumentProcessor()
        logger.info("ğŸ“– æ­£åœ¨åŠ è½½æ–‡æ¡£...")
        
        # åŠ è½½æ–‡æ¡£ï¼ˆç¡®ä¿ data/return_policy.txt å­˜åœ¨ï¼‰
        data_file = "data/return_policy.txt"
        if os.path.exists(data_file):
            documents = processor.load_documents(data_file)
            logger.info(f"âœ… æˆåŠŸåŠ è½½ {len(documents)} ä¸ªæ–‡æ¡£")
        else:
            logger.warning(f"âš ï¸  æ•°æ®æ–‡ä»¶ä¸å­˜åœ¨: {data_file}")
            # åˆ›å»ºç¤ºä¾‹æ•°æ®
            with open(data_file, 'w') as f:
                f.write("é€€è´§æ”¿ç­–ï¼š30å¤©å†…æ— ç†ç”±é€€è´§\nç‰©æµæ—¶é—´ï¼š3-5ä¸ªå·¥ä½œæ—¥\nå®¢æœç”µè¯ï¼š400-123-4567")
            documents = processor.load_documents(data_file)
        
        # åˆå§‹åŒ–å‘é‡æœç´¢
        logger.info("ğŸ”„ åˆå§‹åŒ–å‘é‡æœç´¢ç³»ç»Ÿ...")
        vector_search = VectorSearch()
        vector_search.initialize()
        
        # å¤„ç†æ–‡æ¡£å¹¶æ·»åŠ åˆ°å‘é‡æ•°æ®åº“
        if documents:
            logger.info(f"ğŸ“ æ­£åœ¨å¤„ç† {len(documents)} ä¸ªæ–‡æ¡£...")
            vector_search.add_documents(documents)
            logger.info(f"ğŸ‰ æˆåŠŸå°†æ–‡æ¡£æ·»åŠ åˆ°å‘é‡æ•°æ®åº“")
        
        logger.info("âœ… æ™ºèƒ½å®¢æœç³»ç»Ÿå¯åŠ¨å®Œæˆï¼")
        
    except Exception as e:
        logger.error(f"âŒ ç³»ç»Ÿå¯åŠ¨å¤±è´¥: {e}")
        raise

@app.on_event("shutdown")
async def shutdown_event():
    """å…³é—­äº‹ä»¶ï¼šæ¸…ç†èµ„æº"""
    logger.info("ğŸ›‘ æ­£åœ¨å…³é—­æ™ºèƒ½å®¢æœç³»ç»Ÿ...")

@app.get("/", response_class=HTMLResponse)
async def chat_interface():
    """æä¾›èŠå¤©ç•Œé¢"""
    try:
        # è¯»å–èŠå¤©ç•Œé¢HTMLæ–‡ä»¶
        html_path = "templates/chat.html"
        if os.path.exists(html_path):
            with open(html_path, "r", encoding="utf-8") as f:
                html_content = f.read()
            return HTMLResponse(content=html_content)
        else:
            # å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿”å›ä¸€ä¸ªç®€å•çš„ç•Œé¢
            simple_html = """
            <!DOCTYPE html>
            <html>
            <head><title>æ™ºèƒ½å®¢æœ</title></head>
            <body style="font-family: Arial; padding: 20px;">
                <h1>ğŸ¤– æ™ºèƒ½å®¢æœç³»ç»Ÿ</h1>
                <p>èŠå¤©ç•Œé¢æ–‡ä»¶æœªæ‰¾åˆ°ï¼Œè¯·ç¡®ä¿ templates/chat.html å­˜åœ¨ã€‚</p>
                <p>APIæ–‡æ¡£: <a href="/docs">/docs</a></p>
                <p>æˆ–è€…ç›´æ¥æµ‹è¯•API: 
                <form onsubmit="sendQuestion(); return false;">
                    <input id="question" placeholder="è¾“å…¥é—®é¢˜" style="padding: 5px; width: 300px;">
                    <button type="submit">å‘é€</button>
                </form>
                <div id="answer"></div>
                <script>
                    async function sendQuestion() {
                        const question = document.getElementById('question').value;
                        const response = await fetch('/ask', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({question: question})
                        });
                        const data = await response.json();
                        document.getElementById('answer').innerHTML = `ç­”æ¡ˆ: ${data.answer}`;
                    }
                </script>
            </body>
            </html>
            """
            return HTMLResponse(content=simple_html)
    except Exception as e:
        return HTMLResponse(content=f"<h1>é”™è¯¯</h1><p>{str(e)}</p>", status_code=500)

@app.get("/chat", response_class=HTMLResponse)
async def chat_page():
    """èŠå¤©é¡µé¢ï¼ˆé‡å®šå‘åˆ°é¦–é¡µï¼‰"""
    return RedirectResponse(url="/")

@app.get("/health")
async def health_check():
    """å¥åº·æ£€æŸ¥ç«¯ç‚¹"""
    return {
        "status": "healthy",
        "service": "smart-customer-service",
        "version": "2.0.0",
        "timestamp": datetime.now().isoformat()
    }

@app.get("/system-info")
async def system_info():
    """ç³»ç»Ÿä¿¡æ¯"""
    return {
        "name": "æ™ºèƒ½å®¢æœç³»ç»Ÿ",
        "status": "running",
        "features": ["é—®ç­”ç³»ç»Ÿ", "å‘é‡æœç´¢", "Webç•Œé¢"],
        "endpoints": ["/", "/chat", "/ask", "/health", "/docs", "/redoc"],
        "ai_capabilities": ["æ–‡æ¡£ç†è§£", "è¯­ä¹‰æœç´¢"]
    }

@app.post("/ask", response_model=QuestionResponse)
async def ask_question(request: QuestionRequest):
    """é—®ç­”æ¥å£"""
    try:
        logger.info(f"æ”¶åˆ°é—®é¢˜: {request.question}")
        
        if vector_search is None:
            raise HTTPException(status_code=503, detail="ç³»ç»Ÿæœªåˆå§‹åŒ–å®Œæˆ")
        
        # æœç´¢ç›¸å…³æ–‡æ¡£
        relevant_docs = vector_search.search(request.question, top_k=3)
        
        # ç”Ÿæˆå›ç­”ï¼ˆè¿™é‡Œç®€åŒ–ä¸ºè¿”å›æœ€ç›¸å…³æ–‡æ¡£ï¼‰
        if relevant_docs:
            best_doc = relevant_docs[0]
            answer = f"æ ¹æ®ç›¸å…³ä¿¡æ¯ï¼š{best_doc.get('content', '')[:200]}..."
            confidence = best_doc.get('score', 0.5)
            
            response = {
                "status": "success",
                "answer": answer,
                "confidence": float(confidence),
                "sources": relevant_docs[:3],
                "timestamp": datetime.now().isoformat()
            }
        else:
            response = {
                "status": "success",
                "answer": "æŠ±æ­‰ï¼Œæˆ‘æ²¡æœ‰æ‰¾åˆ°ç›¸å…³çš„ä¿¡æ¯æ¥å›ç­”æ‚¨çš„é—®é¢˜ã€‚",
                "confidence": 0.0,
                "sources": [],
                "timestamp": datetime.now().isoformat()
            }
        
        logger.info(f"é—®é¢˜å¤„ç†å®Œæˆ")
        return response
        
    except Exception as e:
        logger.error(f"å¤„ç†é—®é¢˜æ—¶å‡ºé”™: {e}")
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    logger.info("ğŸŒ å¯åŠ¨WebæœåŠ¡...")
    logger.info("ğŸ“ æœåŠ¡åœ°å€: http://localhost:8000")
    logger.info("ğŸ“š APIæ–‡æ¡£: http://localhost:8000/docs")
    logger.info("ğŸ’¬ èŠå¤©ç•Œé¢: http://localhost:8000/")
    logger.info("â¹ï¸  æŒ‰ Ctrl+C åœæ­¢æœåŠ¡")
    print("-"*50)
    
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info"    )

